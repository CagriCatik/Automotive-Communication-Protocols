"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[8439],{10080:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"LIN/Kommunikation/prozesse","title":"prozesse","description":"LIN-Kommunikation im Fahrzeug","source":"@site/docs/LIN/03_Kommunikation/02_prozesse.md","sourceDirName":"LIN/03_Kommunikation","slug":"/LIN/Kommunikation/prozesse","permalink":"/Vehicle-Network-Standards/docs/LIN/Kommunikation/prozesse","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/LIN/03_Kommunikation/02_prozesse.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"linSidebar","previous":{"title":"prinzip","permalink":"/Vehicle-Network-Standards/docs/LIN/Kommunikation/prinzip"},"next":{"title":"scheduling","permalink":"/Vehicle-Network-Standards/docs/LIN/Kommunikation/scheduling"}}');var t=i(74848),s=i(28453);const a={},l=void 0,d={},o=[{value:"LIN-Kommunikation im Fahrzeug",id:"lin-kommunikation-im-fahrzeug",level:3},{value:"Master-Task und Slave-Task",id:"master-task-und-slave-task",level:4},{value:"Master-Verhalten",id:"master-verhalten",level:4},{value:"Slave-Verhalten",id:"slave-verhalten",level:4},{value:"Technische Details und Protokollstruktur",id:"technische-details-und-protokollstruktur",level:4},{value:"Frame-Struktur",id:"frame-struktur",level:5},{value:"Kommunikationsplan (Schedule Table)",id:"kommunikationsplan-schedule-table",level:5},{value:"Implementierung und Konfiguration",id:"implementierung-und-konfiguration",level:4},{value:"Fehlererkennung und Diagnostik",id:"fehlererkennung-und-diagnostik",level:4}];function u(e){const n={h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h3,{id:"lin-kommunikation-im-fahrzeug",children:"LIN-Kommunikation im Fahrzeug"}),"\n",(0,t.jsx)(n.h4,{id:"master-task-und-slave-task",children:"Master-Task und Slave-Task"}),"\n",(0,t.jsx)(n.p,{children:"In der Local Interconnect Network (LIN) Kommunikation gibt es keinen dedizierten Kommunikationscontroller. Stattdessen wird das Protokoll als Softwarekomponente auf dem Mikrocontroller implementiert. Jeder Knoten in einem LIN-Netzwerk besitzt daher entweder eine Master- oder eine Slave-Task, um die notwendige Kommunikation abzuwickeln. Grunds\xe4tzlich verf\xfcgt jeder Knoten \xfcber eine Slave-Task, die zum Empfangen und Senden von Informationen dient. Der Master-Knoten hat zus\xe4tzlich eine Master-Task, die das Senderecht verteilt und den Buszugriff regelt."}),"\n",(0,t.jsx)(n.h4,{id:"master-verhalten",children:"Master-Verhalten"}),"\n",(0,t.jsx)(n.p,{children:"Wenn ein LIN-Netzwerk in Betrieb genommen wird, wird die Master-Task im Master-Knoten gestartet. Diese beginnt mit der zyklischen Abarbeitung des sogenannten Schedules, das das gew\xfcnschte Sendeschema abbildet. In diesem Schedule sind Slots f\xfcr die einzelnen Botschaften definiert. Diese Slots m\xfcssen gro\xdf genug sein, um sowohl den Frame Header als auch die Frame Response zu \xfcbertragen. In jedem Slot wird immer ein kompletter Frame \xfcbertragen."}),"\n",(0,t.jsx)(n.h4,{id:"slave-verhalten",children:"Slave-Verhalten"}),"\n",(0,t.jsx)(n.p,{children:"F\xfcr die Slave-Tasks wird ein spezifisches Antwortverhalten definiert. Dieses Verhalten legt fest, wie eine Slave-Task auf einen empfangenen Header reagieren soll. M\xf6gliche Reaktionen umfassen das Senden einer Response, das Empfangen einer Response oder das Ignorieren des Headers. Eine gesendete Response kann generell von jeder Slave-Task empfangen werden. Das gew\xfcnschte Antwortverhalten der einzelnen Knoten ist in der LIN Description File (LDF) beschrieben."}),"\n",(0,t.jsx)(n.h4,{id:"technische-details-und-protokollstruktur",children:"Technische Details und Protokollstruktur"}),"\n",(0,t.jsx)(n.h5,{id:"frame-struktur",children:"Frame-Struktur"}),"\n",(0,t.jsx)(n.p,{children:"Ein LIN-Frame besteht aus mehreren Komponenten:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Break-Feld"}),": Signalisiert den Beginn eines Frames."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sync-Feld"}),": Synchronisationsfeld, das die Baudrate festlegt."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identifier-Feld"}),": Beinhaltet die Kennung der Nachricht."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data-Feld"}),": Enth\xe4lt die eigentlichen Nutzdaten."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Checksum-Feld"}),": Dient der Fehlererkennung."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Der Master-Knoten sendet den Break, das Sync-Feld und das Identifier-Feld. Die Slaves reagieren basierend auf ihrer Konfiguration im LDF."}),"\n",(0,t.jsx)(n.h5,{id:"kommunikationsplan-schedule-table",children:"Kommunikationsplan (Schedule Table)"}),"\n",(0,t.jsx)(n.p,{children:"Der Schedule Table ist ein wesentlicher Bestandteil der LIN-Kommunikation. Er definiert, wann welcher Frame gesendet wird und stellt sicher, dass die Kommunikation deterministisch abl\xe4uft. Jeder Eintrag im Schedule Table enth\xe4lt:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slotzeit"}),": Dauer des Slots."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frame-Informationen"}),": Welcher Frame in diesem Slot \xfcbertragen wird."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"implementierung-und-konfiguration",children:"Implementierung und Konfiguration"}),"\n",(0,t.jsx)(n.p,{children:"Die Implementierung eines LIN-Netzwerks erfordert eine sorgf\xe4ltige Planung und Konfiguration:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Master-Task"}),": Muss den Schedule Table korrekt abarbeiten und die Frames gem\xe4\xdf den Zeitvorgaben senden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slave-Task"}),": Muss auf die empfangenen Header korrekt reagieren und die vorgesehenen Daten senden oder empfangen."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Die Konfiguration erfolgt haupts\xe4chlich durch die LIN Description File (LDF), die alle relevanten Informationen wie die Frames, ihre IDs und das Verhalten der Slaves enth\xe4lt."}),"\n",(0,t.jsx)(n.h4,{id:"fehlererkennung-und-diagnostik",children:"Fehlererkennung und Diagnostik"}),"\n",(0,t.jsx)(n.p,{children:"LIN bietet grundlegende Mechanismen zur Fehlererkennung, darunter die Checksum im Frame. Bei der Implementierung m\xfcssen zudem Diagnostik-Frames ber\xfccksichtigt werden, die dem Master und den Slaves erm\xf6glichen, ihren Status mitzuteilen und Fehler zu melden."}),"\n",(0,t.jsx)(n.p,{children:"Durch die genaue Beachtung dieser technischen Details und Protokollstrukturen kann ein robustes und effizientes LIN-Kommunikationsnetzwerk im Fahrzeug aufgebaut werden."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(96540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);