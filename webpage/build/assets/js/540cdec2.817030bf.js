"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[4665],{19048:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"LIN/Kommunikation/prinzip","title":"prinzip","description":"LIN-Kommunikationsprinzipien und ihre Anwendung in Fahrzeug-Elektronik","source":"@site/docs/LIN/03_Kommunikation/01_prinzip.md","sourceDirName":"LIN/03_Kommunikation","slug":"/LIN/Kommunikation/prinzip","permalink":"/Vehicle-Network-Standards/docs/LIN/Kommunikation/prinzip","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/LIN/03_Kommunikation/01_prinzip.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"linSidebar","previous":{"title":"Kommunikation","permalink":"/Vehicle-Network-Standards/docs/LIN/Kommunikation/"},"next":{"title":"prozesse","permalink":"/Vehicle-Network-Standards/docs/LIN/Kommunikation/prozesse"}}');var s=i(74848),t=i(28453);const a={},o=void 0,u={},d=[{value:"LIN-Kommunikationsprinzipien und ihre Anwendung in Fahrzeug-Elektronik",id:"lin-kommunikationsprinzipien-und-ihre-anwendung-in-fahrzeug-elektronik",level:3},{value:"Kommunikationsprinzip",id:"kommunikationsprinzip",level:4},{value:"Buszugriff",id:"buszugriff",level:4},{value:"Einschr\xe4nkungen",id:"einschr\xe4nkungen",level:4},{value:"Botschaftstypen",id:"botschaftstypen",level:4},{value:"Schlussfolgerung",id:"schlussfolgerung",level:4}];function l(e){const n={h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"lin-kommunikationsprinzipien-und-ihre-anwendung-in-fahrzeug-elektronik",children:"LIN-Kommunikationsprinzipien und ihre Anwendung in Fahrzeug-Elektronik"}),"\n",(0,s.jsx)(n.h4,{id:"kommunikationsprinzip",children:"Kommunikationsprinzip"}),"\n",(0,s.jsx)(n.p,{children:"Die LIN-Kommunikation (Local Interconnect Network) basiert auf einer Master-Slave-Architektur. In einem LIN-Cluster gibt es immer einen Master-Knoten, der die gesamte Kommunikation zwischen den verschiedenen Slave-Knoten steuert. Diese Architektur stellt sicher, dass Slaves nur dann Informationen \xfcbertragen, wenn sie dazu vom Master aufgefordert werden. Der Master sendet eine Anfrage (Frame Header) auf den Bus, welche vom entsprechenden Slave um eine Antwort (Frame Response) erg\xe4nzt wird. Diese Kombination aus Anfrage und Antwort wird als Frame bezeichnet."}),"\n",(0,s.jsx)(n.h4,{id:"buszugriff",children:"Buszugriff"}),"\n",(0,s.jsx)(n.p,{children:"Das Buszugriffsverfahren in einem LIN-Cluster wird als Delegated Token bezeichnet. Der Master delegiert das Senden jeder Response, wodurch eine nahezu kollisionsfreie Kommunikation erreicht wird. Dies erm\xf6glicht eine vorhersagbare Daten\xfcbertragung, da auf die Anfragen des Masters nur definierte Antworten folgen k\xf6nnen. Dadurch l\xe4sst sich ein festes Sendeschema (Schedule) erstellen, welches das Verfahren deterministisch macht."}),"\n",(0,s.jsx)(n.h4,{id:"einschr\xe4nkungen",children:"Einschr\xe4nkungen"}),"\n",(0,s.jsx)(n.p,{children:"Ein wesentlicher Nachteil der zentralen Steuerung durch einen Master besteht darin, dass ein Ausfall des Masters die gesamte Kommunikation zum Erliegen bringt. Daher eignet sich das LIN-Bussystem nicht f\xfcr sicherheitskritische Anwendungen, in denen eine permanente Funktion gew\xe4hrleistet sein muss. Zudem ist das Verfahren nicht f\xfcr ereignisorientierte Kommunikation ausgelegt, da die Slaves nicht selbstt\xe4tig auf den Bus zugreifen k\xf6nnen, sondern immer auf eine Anfrage des Masters warten m\xfcssen."}),"\n",(0,s.jsx)(n.h4,{id:"botschaftstypen",children:"Botschaftstypen"}),"\n",(0,s.jsx)(n.p,{children:"Um die Nachteile bei der ereignisorientierten Kommunikation zu kompensieren, wurde LIN um zus\xe4tzliche Botschaftstypen erweitert. Diese erm\xf6glichen unterschiedliche Sendeverhalten, die vom Prinzip des Delegated Token abweichen. Insgesamt gibt es vier Botschaftstypen:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unconditional Frame"}),": Diese Frames enthalten fest definierte Daten und werden regelm\xe4\xdfig vom Master abgefragt, unabh\xe4ngig von \xe4u\xdferen Ereignissen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sporadic Frame"}),": Diese Frames werden nur gesendet, wenn bestimmte Bedingungen erf\xfcllt sind. Der Master fragt diese Frames nicht regelm\xe4\xdfig ab, sondern nur bei Bedarf."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Triggered Frame"}),": Diese Frames werden von Slaves gesendet, wenn ein spezifisches Ereignis eintritt. Der Master sendet eine spezielle Anfrage, auf die mehrere Slaves reagieren k\xf6nnen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Diagnostic Frame"}),": Diese Frames werden f\xfcr Diagnose- und Konfigurationszwecke verwendet. Sie erm\xf6glichen eine gezielte Kommunikation zur Fehlerdiagnose und System\xfcberwachung."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Durch die Einf\xfchrung dieser unterschiedlichen Botschaftstypen wird die Flexibilit\xe4t und Effizienz der LIN-Kommunikation erh\xf6ht, sodass sie auch f\xfcr komplexere Anwendungen geeignet ist."}),"\n",(0,s.jsx)(n.h4,{id:"schlussfolgerung",children:"Schlussfolgerung"}),"\n",(0,s.jsx)(n.p,{children:"Die Master-Slave-Architektur des LIN-Bussystems erm\xf6glicht eine kontrollierte und vorhersagbare Kommunikation innerhalb eines Fahrzeugnetzwerks. Obwohl das System bestimmte Einschr\xe4nkungen, wie die fehlende Eignung f\xfcr sicherheitskritische Anwendungen und ereignisorientierte Kommunikation, aufweist, bieten die erweiterten Botschaftstypen eine L\xf6sung f\xfcr viele Anwendungsf\xe4lle. Durch die richtige Anwendung und Konfiguration kann LIN eine zuverl\xe4ssige und effiziente Kommunikationsl\xf6sung in der Fahrzeug-Elektronik darstellen."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(96540);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);