"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[3929],{2650:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"FLEXRAY/Framing/frame-payload","title":"FlexRay-Tutorial: Nachrichten\xfcbertragung und Fehlererkennung im Fahrzeugnetzwerk","description":"In diesem Tutorial werden wir uns intensiv mit dem FlexRay-Kommunikationsprotokoll besch\xe4ftigen, das in der Fahrzeugelektrik und -elektronik weit verbreitet ist. Wir werden die Struktur der Nachrichten\xfcbertragung sowie die Mechanismen zur Fehlererkennung im FlexRay-Netzwerk untersuchen. Dabei werden wir die Spezifikationen und Funktionen pr\xe4zise und detailliert erl\xe4utern.","source":"@site/docs/FLEXRAY/04_Framing/02_frame-payload.md","sourceDirName":"FLEXRAY/04_Framing","slug":"/FLEXRAY/Framing/frame-payload","permalink":"/Vehicle-Network-Standards/docs/FLEXRAY/Framing/frame-payload","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/FLEXRAY/04_Framing/02_frame-payload.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"flexraySidebar","previous":{"title":"frame-header","permalink":"/Vehicle-Network-Standards/docs/FLEXRAY/Framing/frame-header"},"next":{"title":"FlexRay-Tutorial: Physikalische \xdcbertragung und Codierung von Nachrichten","permalink":"/Vehicle-Network-Standards/docs/FLEXRAY/Framing/codierung"}}');var t=r(74848),a=r(28453);const s={},d="FlexRay-Tutorial: Nachrichten\xfcbertragung und Fehlererkennung im Fahrzeugnetzwerk",l={},h=[{value:"1. Nachrichten\xfcbertragung im FlexRay-Netzwerk",id:"1-nachrichten\xfcbertragung-im-flexray-netzwerk",level:2},{value:"1.1 Struktur der FlexRay-Nachricht",id:"11-struktur-der-flexray-nachricht",level:3},{value:"1.2 Payload Length",id:"12-payload-length",level:3},{value:"1.3 Network Management Vector",id:"13-network-management-vector",level:3},{value:"1.4 Dynamische Nachrichten und Message Identifier",id:"14-dynamische-nachrichten-und-message-identifier",level:3},{value:"1.5 Null Frame",id:"15-null-frame",level:3},{value:"2. Fehlererkennung im FlexRay-Netzwerk",id:"2-fehlererkennung-im-flexray-netzwerk",level:2},{value:"2.1 CRC-Verfahren",id:"21-crc-verfahren",level:3},{value:"2.2 Fehlererkennung und Hamming-Distanz",id:"22-fehlererkennung-und-hamming-distanz",level:3},{value:"Kritische Betrachtung",id:"kritische-betrachtung",level:2},{value:"Fazit",id:"fazit",level:2}];function c(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"flexray-tutorial-nachrichten\xfcbertragung-und-fehlererkennung-im-fahrzeugnetzwerk",children:"FlexRay-Tutorial: Nachrichten\xfcbertragung und Fehlererkennung im Fahrzeugnetzwerk"})}),"\n",(0,t.jsx)(n.p,{children:"In diesem Tutorial werden wir uns intensiv mit dem FlexRay-Kommunikationsprotokoll besch\xe4ftigen, das in der Fahrzeugelektrik und -elektronik weit verbreitet ist. Wir werden die Struktur der Nachrichten\xfcbertragung sowie die Mechanismen zur Fehlererkennung im FlexRay-Netzwerk untersuchen. Dabei werden wir die Spezifikationen und Funktionen pr\xe4zise und detailliert erl\xe4utern."}),"\n",(0,t.jsx)(n.h2,{id:"1-nachrichten\xfcbertragung-im-flexray-netzwerk",children:"1. Nachrichten\xfcbertragung im FlexRay-Netzwerk"}),"\n",(0,t.jsx)(n.h3,{id:"11-struktur-der-flexray-nachricht",children:"1.1 Struktur der FlexRay-Nachricht"}),"\n",(0,t.jsx)(n.p,{children:"Eine FlexRay-Nachricht besteht aus mehreren Teilen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Header"}),": Enth\xe4lt Steuerinformationen, einschlie\xdflich des Payload Preamble Indicators und des Null Frame Indicators."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Payload"}),": Der eigentliche Nutzdatenbereich der Nachricht, der bis zu 254 Nutzbytes (Payload) transportieren kann."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Trailer"}),": Enth\xe4lt die CRC-Sequenz zur Fehlererkennung."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"12-payload-length",children:"1.2 Payload Length"}),"\n",(0,t.jsxs)(n.p,{children:["Der Parameter ",(0,t.jsx)(n.strong,{children:"Payload Length"})," gibt die Gr\xf6\xdfe des Payloads in Words (ein Word entspricht zwei Bytes) an. Im statischen Segment haben alle \xfcbertragenen Nachrichten dieselbe Payload Length, die vom Systemdesigner w\xe4hrend der Konfigurationsphase festgelegt wird. Im dynamischen Segment k\xf6nnen Nachrichten verschiedene Payload Length-Werte haben, da sie nicht an eine feste Gr\xf6\xdfe gebunden sind."]}),"\n",(0,t.jsx)(n.h3,{id:"13-network-management-vector",children:"1.3 Network Management Vector"}),"\n",(0,t.jsxs)(n.p,{children:["Bei Nachrichten im statischen Segment k\xf6nnen die ersten zw\xf6lf Nutzbytes f\xfcr die \xdcbertragung des ",(0,t.jsx)(n.strong,{children:"Network Management Vectors"})," verwendet werden. Daf\xfcr muss der ",(0,t.jsx)(n.strong,{children:"Payload Preamble Indicator"})," im Header gesetzt werden. Der Network Management Vector dient der Realisierung des Netzmanagements in einem FlexRay-Cluster."]}),"\n",(0,t.jsx)(n.h3,{id:"14-dynamische-nachrichten-und-message-identifier",children:"1.4 Dynamische Nachrichten und Message Identifier"}),"\n",(0,t.jsxs)(n.p,{children:["Wenn der Payload Preamble Indicator bei einer dynamischen FlexRay-Nachricht gesetzt ist, signalisiert dies, dass die ersten zwei Nutzbytes den ",(0,t.jsx)(n.strong,{children:"Message Identifier"})," enthalten. Dieser Message Identifier erm\xf6glicht eine differenziertere Akzeptanzfilterung der Nachricht durch den Systemdesigner."]}),"\n",(0,t.jsx)(n.h3,{id:"15-null-frame",children:"1.5 Null Frame"}),"\n",(0,t.jsx)(n.p,{children:"In speziellen F\xe4llen kann eine Nachricht ausschlie\xdflich mit Nullen \xfcbertragen werden, wenn der zugeh\xf6rige Puffer vom Host gesperrt ist. Dies geschieht, wenn der FlexRay-Controller eine statische Nachricht senden muss, aber keinen Zugriff auf den Puffer hat. Der Header der Nachricht enth\xe4lt dann einen Null Frame Indicator, der den Wert \u201eNull\u201c aufweist."}),"\n",(0,t.jsx)(n.h2,{id:"2-fehlererkennung-im-flexray-netzwerk",children:"2. Fehlererkennung im FlexRay-Netzwerk"}),"\n",(0,t.jsx)(n.h3,{id:"21-crc-verfahren",children:"2.1 CRC-Verfahren"}),"\n",(0,t.jsxs)(n.p,{children:["Zur Sicherung des Payloads wird das ",(0,t.jsx)(n.strong,{children:"Cyclic Redundancy Check (CRC)"}),"-Verfahren eingesetzt. Dieses leistungsstarke Fehlererkennungsverfahren berechnet auf Basis des Headers und Payloads sowie einem durch die FlexRay-Spezifikation definierten Generatorpolynom eine CRC-Sequenz. Diese Sequenz wird dem Header und Payload als Trailer angeh\xe4ngt."]}),"\n",(0,t.jsx)(n.h3,{id:"22-fehlererkennung-und-hamming-distanz",children:"2.2 Fehlererkennung und Hamming-Distanz"}),"\n",(0,t.jsx)(n.p,{children:"Die CRC-Checksumme stellt sicher, dass \xdcbertragungsfehler mit hoher Sicherheit erkannt werden. Ein Fehler wird festgestellt, wenn die Division der empfangenen Nachricht durch das Generatorpolynom einen Rest ergibt. Die Fehlererkennungsf\xe4higkeit des CRC-Verfahrens h\xe4ngt von der Gr\xf6\xdfe des Payloads ab:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Bei einem Payload bis zu 248 Bytes wird eine ",(0,t.jsx)(n.strong,{children:"Hamming-Distanz"})," von sechs garantiert."]}),"\n",(0,t.jsx)(n.li,{children:"Bei gr\xf6\xdferen Payloads liegt die Hamming-Distanz bei vier, was zu einer geringeren Fehlererkennungsf\xe4higkeit f\xfchrt."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Die Hamming-Distanz gibt an, wie viele Bitfehler auftreten m\xfcssen, damit ein Fehler nicht erkannt wird. Eine gr\xf6\xdfere Hamming-Distanz bedeutet eine h\xf6here Fehlererkennungsf\xe4higkeit."}),"\n",(0,t.jsx)(n.h2,{id:"kritische-betrachtung",children:"Kritische Betrachtung"}),"\n",(0,t.jsx)(n.p,{children:"Es ist wichtig, einige Punkte kritisch zu betrachten:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Payload Length im statischen Segment"}),": W\xe4hrend die Aussage korrekt ist, dass alle statischen Nachrichten dieselbe Payload Length haben, ist es unerl\xe4sslich, dass die Systemdesigner sorgf\xe4ltig die Anforderungen jeder Nachricht ber\xfccksichtigen, um die Effizienz des Netzwerks zu maximieren."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Network Management Vector"}),": Der Einsatz des Network Management Vectors ist spezifisch f\xfcr das Netzmanagement und sollte nicht mit anderen Steuerinformationen verwechselt werden. Es ist entscheidend, dass der Payload Preamble Indicator korrekt gesetzt wird, um Missverst\xe4ndnisse zu vermeiden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fehlererkennung durch CRC"}),": Obwohl das CRC-Verfahren sehr effektiv ist, bedeutet eine Hamming-Distanz von vier bei gr\xf6\xdferen Payloads eine signifikante Verringerung der Fehlererkennungsf\xe4higkeit. Systemdesigner sollten dies bei der Planung und Konfiguration des Netzwerks ber\xfccksichtigen."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"fazit",children:"Fazit"}),"\n",(0,t.jsx)(n.p,{children:"Das FlexRay-Kommunikationsprotokoll bietet robuste Mechanismen zur Nachrichten\xfcbertragung und Fehlererkennung, die f\xfcr den Einsatz in der Fahrzeugelektrik und -elektronik optimiert sind. Die korrekte Konfiguration und Anwendung dieser Mechanismen ist entscheidend f\xfcr die Zuverl\xe4ssigkeit und Sicherheit des Netzwerks. Durch die genaue Beachtung der Spezifikationen und die sorgf\xe4ltige Planung k\xf6nnen Systemdesigner sicherstellen, dass das FlexRay-Netzwerk effizient und fehlerfrei arbeitet."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var i=r(96540);const t={},a=i.createContext(t);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);