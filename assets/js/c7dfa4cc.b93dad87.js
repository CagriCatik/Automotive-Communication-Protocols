"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[8706],{32680:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>u,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"SOVA/architecture-specific/zonal/fortgeschritten","title":"Service-orientierte Fahrzeugarchitektur","description":"Die service-orientierte Fahrzeugarchitektur bildet eine zentrale Grundlage f\xfcr die moderne Fahrzeugtechnik. Diese Architektur basiert auf einem verteilten System, in dem verschiedene Komponenten und Services miteinander interagieren. Zur Realisierung dieser Architektur wurden spezifische Design Patterns entwickelt, die eine effiziente und robuste Kommunikation zwischen den Komponenten gew\xe4hrleisten. Ein wesentlicher Bestandteil dieser Architektur ist die Onboard Vehicle API, die als Schnittstelle f\xfcr den Zugriff auf Fahrzeugfunktionen dient. Das Design und die Implementierung von SOME/IP Services, die \xfcber diese API angeboten werden, erfordert eine methodische Vorgehensweise und die Ber\xfccksichtigung von Best Practices. Bei der Entwicklung eines Services auf der Onboard Vehicle API ist es entscheidend, die geeigneten Design Patterns und Vorgaben zu beachten. Hierbei steht die Funktionalit\xe4t der spezifischen Funktion oder des Systems im Vordergrund. Es ist von gro\xdfer Bedeutung, eine klare Schnittstellenbeschreibung zu erstellen, um die Interaktion mit dem Service zu definieren. Zudem sollten Aspekte wie die Versionierung der Schnittstelle, die Behandlung von Fehlern und die Sicherheit der Kommunikation ber\xfccksichtigt werden. Ein weiterer wichtiger Punkt ist die Ber\xfccksichtigung von Skalierbarkeit und Performance. Der Service sollte in der Lage sein, eine Vielzahl von Anfragen effizient zu verarbeiten und dabei eine hohe Zuverl\xe4ssigkeit zu gew\xe4hrleisten. Hierbei k\xf6nnen bew\xe4hrte Techniken aus dem Bereich der verteilten Systeme und der Softwarearchitektur zum Einsatz kommen. Zusammenfassend l\xe4sst sich sagen, dass die Entwicklung von Services auf der Onboard Vehicle API eine sorgf\xe4ltige Planung und Umsetzung erfordert. Die Beachtung der Design Patterns und Vorgaben f\xfcr Service Design und Implementierung ist entscheidend, um eine robuste und leistungsf\xe4hige Architektur zu gew\xe4hrleisten. Dies tr\xe4gt ma\xdfgeblich zur Funktionalit\xe4t und Zuverl\xe4ssigkeit moderner Fahrzeugtechnik bei.","source":"@site/docs/SOVA/02_architecture-specific/04_zonal/02_fortgeschritten.md","sourceDirName":"SOVA/02_architecture-specific/04_zonal","slug":"/SOVA/architecture-specific/zonal/fortgeschritten","permalink":"/Vehicle-Network-Standards/docs/SOVA/architecture-specific/zonal/fortgeschritten","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/SOVA/02_architecture-specific/04_zonal/02_fortgeschritten.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"sovaSidebar","previous":{"title":"Service-orientierte Fahrzeugarchitektur","permalink":"/Vehicle-Network-Standards/docs/SOVA/architecture-specific/domain/fortgeschritten"},"next":{"title":"Core Concepts of Service-Oriented Architectures","permalink":"/Vehicle-Network-Standards/docs/category/core-concepts-of-service-oriented-architectures"}}');var t=i(74848),s=i(28453);const d={},u="Service-orientierte Fahrzeugarchitektur",a={},c=[{value:"SOME/IP",id:"someip",level:2},{value:"Funktionsweise vom Datenaustausch zwischen Service Provider und Client(s)",id:"funktionsweise-vom-datenaustausch-zwischen-service-provider-und-clients",level:2}];function o(e){const n={h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"service-orientierte-fahrzeugarchitektur",children:"Service-orientierte Fahrzeugarchitektur"})}),"\n",(0,t.jsx)(n.p,{children:"Die service-orientierte Fahrzeugarchitektur bildet eine zentrale Grundlage f\xfcr die moderne Fahrzeugtechnik. Diese Architektur basiert auf einem verteilten System, in dem verschiedene Komponenten und Services miteinander interagieren. Zur Realisierung dieser Architektur wurden spezifische Design Patterns entwickelt, die eine effiziente und robuste Kommunikation zwischen den Komponenten gew\xe4hrleisten. Ein wesentlicher Bestandteil dieser Architektur ist die Onboard Vehicle API, die als Schnittstelle f\xfcr den Zugriff auf Fahrzeugfunktionen dient. Das Design und die Implementierung von SOME/IP Services, die \xfcber diese API angeboten werden, erfordert eine methodische Vorgehensweise und die Ber\xfccksichtigung von Best Practices. Bei der Entwicklung eines Services auf der Onboard Vehicle API ist es entscheidend, die geeigneten Design Patterns und Vorgaben zu beachten. Hierbei steht die Funktionalit\xe4t der spezifischen Funktion oder des Systems im Vordergrund. Es ist von gro\xdfer Bedeutung, eine klare Schnittstellenbeschreibung zu erstellen, um die Interaktion mit dem Service zu definieren. Zudem sollten Aspekte wie die Versionierung der Schnittstelle, die Behandlung von Fehlern und die Sicherheit der Kommunikation ber\xfccksichtigt werden. Ein weiterer wichtiger Punkt ist die Ber\xfccksichtigung von Skalierbarkeit und Performance. Der Service sollte in der Lage sein, eine Vielzahl von Anfragen effizient zu verarbeiten und dabei eine hohe Zuverl\xe4ssigkeit zu gew\xe4hrleisten. Hierbei k\xf6nnen bew\xe4hrte Techniken aus dem Bereich der verteilten Systeme und der Softwarearchitektur zum Einsatz kommen. Zusammenfassend l\xe4sst sich sagen, dass die Entwicklung von Services auf der Onboard Vehicle API eine sorgf\xe4ltige Planung und Umsetzung erfordert. Die Beachtung der Design Patterns und Vorgaben f\xfcr Service Design und Implementierung ist entscheidend, um eine robuste und leistungsf\xe4hige Architektur zu gew\xe4hrleisten. Dies tr\xe4gt ma\xdfgeblich zur Funktionalit\xe4t und Zuverl\xe4ssigkeit moderner Fahrzeugtechnik bei."}),"\n",(0,t.jsx)(n.h2,{id:"someip",children:"SOME/IP"}),"\n",(0,t.jsx)(n.p,{children:'Service-Oriented Middleware over IP (SOME/IP) ist eine spezielle Technologie, die in der Automobilindustrie zur Realisierung der Service-orientierten Kommunikation innerhalb von Fahrzeugen verwendet wird. Dieses Protokoll erm\xf6glicht den Datenaustausch zwischen Service-Providern (Server) und anfragenden Clients im Kontext des Systems Engineering im Automobilsektor. Die Entwicklung und Standardisierung von SOME/IP wurde ma\xdfgeblich vom AUTOSAR-Konsortium vorangetrieben und wird kontinuierlich von verschiedenen Unternehmen weiterentwickelt. SOME/IP dient als Standardprotokoll f\xfcr den Datenaustausch \xfcber Service-Schnittstellen innerhalb eines Fahrzeugs und fungiert als Middleware f\xfcr Service-orientierte Architekturen (SOA), um den Datenaustausch zwischen Servern und Clients zu erleichtern. Es setzt sich aus drei grundlegenden Technologiebl\xf6cken zusammen: "Service Discovery" (Diensterkennung), "Serialisierung" (Datenformatierung) und "Transport Protocols" (Transportprotokolle). Die "Service Discovery" erm\xf6glicht es, verf\xfcgbare Dienste im Netzwerk zu identifizieren und auf sie zuzugreifen. Die "Serialisierung" ist f\xfcr die Umwandlung von Daten in ein geeignetes Format verantwortlich, um sie zwischen den Kommunikationspartnern austauschbar zu machen. Schlie\xdflich k\xfcmmert sich das "Transport Protocols" um die eigentliche \xdcbertragung der Daten zwischen den Servern und den Clients. Insgesamt tr\xe4gt SOME/IP dazu bei, die Kommunikation und den Datenaustausch innerhalb von Fahrzeugen effizienter und standardisiert zu gestalten. Diese Technologie wird weiterhin in der Automobilbranche entwickelt und verbessert, um den steigenden Anforderungen an die Vernetzung und den Informationsaustausch innerhalb moderner Fahrzeuge gerecht zu werden.'}),"\n",(0,t.jsx)(n.h2,{id:"funktionsweise-vom-datenaustausch-zwischen-service-provider-und-clients",children:"Funktionsweise vom Datenaustausch zwischen Service Provider und Client(s)"}),"\n",(0,t.jsx)(n.p,{children:'Der Datenaustausch zwischen Service Provider und Client(s) f\xfcr die Bereitstellung von Services \xfcber SOME/IP erfolgt mithilfe von zwei zentralen Mechanismen: der Service Discovery und der Serialisierung. Im Kontext dieser Betrachtung liegt der Fokus auf dem Request-Response Mechanismus. Die Service Discovery stellt einen Mechanismus dar, der die Ethernet-Kommunikation zwischen Electronic Control Units (ECUs) erm\xf6glicht, ohne dass eine fest definierte Zuordnung von Sendern und Empf\xe4ngern der Daten erforderlich ist. Jede ECU definiert stattdessen ein Set von Provider Service Instanzen, die zur Bereitstellung von Services dienen, sowie erforderliche Service Instanzen. W\xe4hrend der Laufzeit nutzt der Service Discovery Mechanismus diese Definitionen, um die Provider Service Instanzen bereitzustellen und die erforderlichen Service Instanzen zu finden (Find and Offer). Es ist dabei zu beachten, dass ein Broadcast nicht m\xf6glich ist, wodurch Services oder Service Instanzen, die nicht bekannt sind, nicht gefunden werden k\xf6nnen. Diese Vorgehensweise ist unerl\xe4sslich, da ohne Kenntnis der Struktur des Service Interfaces die Daten nicht interpretiert werden k\xf6nnten. Der Begriff der Serialisierung bezieht sich auf den Prozess, bei dem Datenstrukturen oder Objekte in ein Format \xfcbersetzt werden, das gespeichert und \xfcbertragen werden kann und anschlie\xdfend rekonstruiert werden kann. Konkret bedeutet dies, dass die Abfolge der Bits der Datenstruktur so formatiert wird, dass sie \xfcber ein Netzwerk \xfcbertragen werden kann. F\xfcr die Serialisierung von Daten im Fahrzeug und deren \xdcbertragung \xfcber das Ethernet Netzwerk, also den Ethernet Bus, definiert SOME/IP allgemeine Architekturpattern. Diese Muster, welche das Request- und Response- Verhalten f\xfcr die Bereitstellung von Services festlegen, werden im Folgenden als "Service Design Patterns" bezeichnet.'})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>u});var r=i(96540);const t={},s=r.createContext(t);function d(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);